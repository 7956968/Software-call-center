using NAudio.Dsp;
using System;

namespace RedFox.Consumers.Loopback
{
    /// <summary>
    /// A class that wraps the WdlResampler from NAudio. This is intended for input-driven resampling. Use the
    /// WdlResamplingSampleProvider for output-driven resampling.
    /// </summary>
    public class ResamplerWrapper
    {
        readonly WdlResampler _resampler = new WdlResampler();

        private readonly int _channels = 1;

        public ResamplerWrapper(int channels)
        {
            if (channels > 5 || channels < 1)
            {
                throw new ArgumentOutOfRangeException(nameof(channels));
            }

            _channels = channels;
        }

        /// <summary>
        /// Engages the specified source floats. This doc was autogenerated so it's weird.
        /// </summary>
        /// <param name="sourceFloats">The source floats.</param>
        /// <param name="resampledResult">The resampled result.</param>
        /// <param name="sampleRateIn">The sample rate in.</param>
        /// <param name="sampleRateOut">The sample rate out.</param>
        /// <returns>the number of samples processed</returns>
        public int Engage(float[] sourceFloats,
            out float[] resampledResult,
            int sampleRateIn,
            int sampleRateOut)
        {
            int sourceLength = sourceFloats.Length;
            return Engage(sourceFloats, sourceLength, out resampledResult, sampleRateIn, sampleRateOut);
        }

        /// <summary>
        /// Engages the specified source floats. This doc was autogenerated so it's weird.
        /// </summary>
        /// <param name="sourceFloats">The source floats.</param>
        /// <param name="sourceLength">Length of the source -- how many floats to use from the provided buffer.</param>
        /// <param name="resampledResult">The resampled result.</param>
        /// <param name="sampleRateIn">The sample rate in.</param>
        /// <param name="sampleRateOut">The sample rate out.</param>
        /// <returns>
        /// the number of samples processed
        /// </returns>
        public int Engage(float[] sourceFloats,
            int sourceLength,
            out float[] resampledResult,
            int sampleRateIn,
            int sampleRateOut)
        {
            // The resampler code is very delicate. I don't recommend messing with it unless you have a week to
            // spend on it.
            // See https://gist.github.com/markheath/dc41131fefb84b93b041f1dde8a08209 for more info
            _resampler.SetMode(false, 0, false);
            _resampler.SetFilterParms();
            _resampler.SetRates(sampleRateIn, sampleRateOut);
            _resampler.SetFeedMode(true); // input driven

            float[] inData;
            int inBufferOffset;
            int inputFrameCount = sourceLength / _channels;
            int framesExpected = _resampler.ResamplePrepare(inputFrameCount, _channels, out inData, out inBufferOffset);

            // Feed the samples into the resampler's byte array.
            Array.Copy(sourceFloats, 0, inData, inBufferOffset, framesExpected * _channels);
            var ratio = (double)sampleRateIn / sampleRateOut;

            double expected = (double)framesExpected * _channels / ratio;

            // round upward to nearest complete frame to prevent data loss
            int roundedSamples = (int)Math.Ceiling(expected / _channels) * _channels;
            resampledResult = new float[roundedSamples];

            // the return value is the Inverse of what would actually be helpful
            int framesProcessed = _resampler.ResampleOut(resampledResult, 0, framesExpected, roundedSamples, _channels);
            return framesProcessed * 2;
        }
    }
}